instalar via composer -> cmd -> composer create-project --prefer-dist laravel/laravel nomedoProjeto
----------------------------------------------------
iniciar servidor laravel -> php artisan serve
parar o servidor -> ctrl + c
para acessar -> localhost:8000
-------------------------------------------------
iniciar via xampp -> colar a pasta do projeto na pasta htdocs -> acessar normalmente -> localhost/nomedoProjeto/public
---------------------------------------
a pasta vendor não vai para o git, para baixar em outro local -> composer install (vai ler o conteúdo do arquivo composer.json) 
------------------------------------------
configurar o projeto antes de enviar para o servidor -> php artisan cache:clear / php artisan route:clear / php artisan route:cache / apagar os arquivos dentro da pasta storage/framework/sessions
------------------------------------------------------------------
Rotas
listar todas as rotas -> php artisan route:list
rotas definidas no arquivo web.php da pasta routes

Tipos de rotas
Route::get('/', function () {
	return "<h1>Laravel</h1>";
});

Route::get('/ola', function () {
	return "<h1>Seja Bem-vindo!!!</h1>";
});

Route::get('/ola/sejabemvindo', function () {
	return view('welcome');
});

Route::view('/hello', 'hello'); //forma abreviada chamando a rota e a view

Route::view('/viewnome', 'hellonome', ['nome' => 'Nome', 'sobrenome' => 'Sobrenome']); //forma abreviada chamando a rota, a view e passando variáveis

Route::get('/hellonome/{nome}/{sobrenome}', function ($nome, $sn) {
	//forma normal chamando a rota, a view e passando variáveis
	return view('hellonome', [
		'nome' => $nome,
		'sobrenome' => $sn,
	]);
});

//o nome da variável não precisa ser igual ao do parâmetro da função callback
//mas os dados deve estar na mesma ordem e na mesma quantidade das variáveis
Route::get('/nome/{nome}/{sobrenome}', function ($nome, $sn) {
	return "<h1>Ola, $nome, $sn!</h1>";
});

//criar restrição na passagem dos parâmetros da rota  por meio de expressão regular
Route::get('/seunomecomregra/{nome}/{n}', function ($nome, $n) {
	for ($i = 0; $i < $n; $i++) {
		echo "<h1>Ola, $nome, $n!</h1>";
	}
	
})->where('n', '[0-9]+')->where('nome', '[A-Za-z]+');

Route::get('/seunomesemregra/{nome?}', function ($nome = null) {
	// o ? torna o parâmetro opcional
	if (isset($nome)) {
		echo "<h1>Ola, $nome!</h1>";
	} else {
		echo 'Você não passou nenhum nome';
	}
});

//agrupamento de rotas -> app/ -> app/profile/ -> app/about
Route::prefix('app')->group(function () {
	Route::get('/', function () {
		return "Página principal do APP";
	});
	Route::get('profile', function () {
		return "Página profile";
	});
	Route::get('about', function () {
		return "Página about";
	});
});

//redirecionamento de rotas (/aqui para /ola)
Route::redirect('/aqui', '/ola', 301); 

//outra forma de redirecionamento de rota
Route::get('/redirecionarprodutos', function () {
	return redirect()->route('meusprodutos'); 
});

//tipos de requisições (GET somente solicita algo do servidor, já os outros tipos alteram os arquivos do servidor)
Route::get('/rest/hello', function () {
	return "Hello (Get)"; //mostra dados
});

Route::post('/rest/hello', function () {
	return "Hello (Post)"; //altera os dados do servidor por meio de formulário
});

Route::delete('/rest/hello', function () {
	return "Hello (Delete)"; //deleta dados
});

Route::put('/rest/hello', function () {
	return "Hello (Put)"; //atualiza dados
});

Route::patch('/rest/hello', function () {
	return "Hello (Patch)";
});

Route::options('/rest/hello', function () {
	return "Hello (Options)";
});

// utilizando o método post
use Illuminate\Http\Request; //é necessário incluir essa linha de comando

Route::post('/rest/imprimir', function (Request $req) {
	$nome = $req->input('nome'); //pega os dados do campo do formulário
	$idade = $req->input('idade'); //pega os dados do campo do formulário
	return "Hello $nome ($idade)!";
});

// agrupando requisições em uma rota
Route::match(['get', 'post'], '/rest/hello2', function () {
	return "Hello World 2!";
});

// atende a qualquer requisição
Route::any('/rest/hello3', function () {
	return "Hello World 3!";
});

// nomear rotas
Route::get('/produtos', function () {
	echo "<h1>Produtos<h1>";
	echo "<ol>";
	echo "<li>Notebook</li>";
	echo "<li>Impressora</li>";
	echo "<li>Mouse</li>";
	echo "</ol>";
})->name('meusprodutos'); //nomeando a rota

// utilizando a rota nomeada
Route::get('/linkprodutos', function () {
	$url = route('meusprodutos'); //utilizando a rota acima
	echo '<a href="' . $url . '">Meus produtos</a>';
});

Route::get('/redirecionarprodutos', function () {
	return redirect()->route('meusprodutos'); //outra forma de redirecionamento de rota
}); 

//para utilizar rota post é preciso utilizar -> use Illuminate\Http\Request;

//limitar os métodos do resource
Route::resource('produtos', 'ProdutoControlador')->only([
    'index', 'store'
]);
Route::get('produto/{id}', 'ProdutoControlador@show')
    ->where('id', '[0-9]+'); //filtrando os dados passados pela rota por meio de expressão regular
Route::delete('produto/{id}', 'ProdutoControlador@destroy')
    ->where('id', '[0-9]+');

---------------------------------------
verificar rotas -> instalar extensão -> Advanced REST client
para acessar pelo chrome -> chrome://apps
-------------------------------------
permitir exceções de requisições -> pasta app/Http/Middleware/VerifyCsrfToken.php -> incluir a rota em ->
protected $except = [
		'/rest*', //rota aqui, o * é para pegar tudo após a rota
	];
---------------------------------------------------------
#Controller
criar controller -> php artisan make:controller MeuControlador
criar controller com os métodos específicos para alterações/visualizações de dados (criará dentro do controlador os métodos -> index();  create(); store(Request $request); show($id); edit($id); update(Request $request, $id); destroy($id)) -> php artisan make:controller MeuControlador --resource
localização dos controladores -> app/Http/Controllers
configurar rota para o controlador -> 
	controlador -> 
		namespace App\Http\Controllers;

		class MeuControlador extends Controller {
			public function getNome() {
				return "José da Silva";
			}
		}
	rota -> Route::get('/nome', 'MeuControlador@getNome');

utilizando a rota para chamar o controlador ->
	Route::get('/nome', 'MeuControlador@getNome'); //utlizando o controlador
	Route::get('/idade', 'MeuControlador@getIdade'); //utlizando o controlador
	Route::get('/multiplicar/{n1}/{n2}', 'MeuControlador@multiplicar'); //passando parâmetros ao controlador
	Route::get('/nomes/{id}', 'MeuControlador@getNomeByID'); //passando parâmetros ao controlador
	Route::resource('/cliente', 'ClienteControlador'); //resource acessa os métodos específicos criados no controlador pelo comando php artisan make:controller MeuControlador --resource

como fica no controlador -> 
	public function getIdade() {
		return "20 anos";
	}

	public function getNome() {
		return "José da Silva";
	}

	public function getNomeByID($id) {
		$v = ["Mario", "Edson", "Roberto", "Jean"];
		if ($id >= 0 && $id < count($v)) {
			return $v[$id];
		} else {
			return "Não encontrado";
		}
	}

	public function multiplicar($n1, $n2) {
		return $n1 * $n2;
	}

//modelos de controllers
namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ClienteControlador extends Controller {
	//página de cadastro
	public function create() {
		return "Formulário para Cadastrar novo Cliente";
	}

	// deleta dados
	public function destroy($id) {
		return response("Apagado cliente com id $id", 200);
	}

	//página carrega dados para edição
	public function edit($id) {
		return "Formulário para Editar Cliente com ID " . $id;
	}

	// página inicial - padrão
	public function index() {
		return "Lista de todos os Clientes - Raiz";
	}

	// método não faz parte do resource
	public function requisitar(Request $request) {
		echo "nome: " . $request->input('nome');
	}

	// página que seleciona dados por id
	public function show($id) {
		$v = ["Mario", "Edson", "Roberto", "Jean"];
		if ($id >= 0 && $id < count($v)) {
			return $v[$id];
		} else {
			return "Não encontrado";
		}
	}

	//salva dados
	public function store(Request $request) {
		$s = "Armazenar: ";
		$s .= "Nome: " . $request->input('nome') . " e ";
		$s .= "Idade: " . $request->input('idade');
		return response($s, 201); //código para dados salvos com sucesso
	}

	// atualiza os dados
	public function update(Request $request, $id) {
		$s = "Atualizar Cliente com id $id: ";
		$s .= "Nome: " . $request->input('nome') . " e ";
		$s .= "Idade: " . $request->input('idade');
		return response($s, 201); //código para dados salvos com sucesso
	}

//rotas para os controllers acima
Route::get('/nome', 'MeuControlador@getNome'); //utlizando o controlador
Route::get('/idade', 'MeuControlador@getIdade'); //utlizando o controlador
Route::get('/multiplicar/{n1}/{n2}', 'MeuControlador@multiplicar'); //passando parâmetros ao controlador
Route::get('/nomes/{id}', 'MeuControlador@getNomeByID'); //passando parâmetros ao controlador
Route::resource('/cliente', 'ClienteControlador'); //resource acessa todos os métodos criados no controlador pelo comando --resource
Route::post('/cliente/requisitar', 'ClienteControlador@requisitar'); //resource acessa todos os métodos criados no controlador pelo comando --resource
---------------------------------------------------------
Código 200 e 201
200 -> O 200 serve para o servidor responder ao cliente que a requisição que ele fez foi atendida. Esse código de resposta acompanha o recurso que foi pedido pelo cliente, que pode ser uma página html, uma figura, ou um arquivo, por exemplo.

201 -> Já o 201 é utilizado especificamente quando você faz um POST ao servidor para criar um novo registro na base de dados. Se esse registro foi criado com sucesso, o servidor retorna um 201, dizendo que um recurso foi criado.

---------------------------------------------------------
o PUT é para atualização total e o PATCH para atualização parcial de uma entidade.
----------------------------------------------------------
#View
localização -> resources -> views
receber dados na view -> 
	<!DOCTYPE html>
	<html>
	<head>
		<title>Minha página</title>
	</head>
	<body>
		<!-- recendo valores das rotas -->
		<h1>Hello, {{$nome}} {{$sobrenome}}</h1>
	</body>
	</html>
verificar se view existe ->
	Route::get('/email/{email}', function ($email) {
		if (View::exists('email')) {
			return view('email', compact('email'));
		} else {
			return view('erro');
		}
	});
rota padrão de erro do Laravel -> resources/views/errors/404.blade.php

template -> 
<!DOCTYPE html>
<html>
<head>
	<title>Meu título - @yield('titulo')</title>
</head>
<body>
	<div>
		<!-- seção compartilhada entre pai e filho -->

		@section('barralateral')
			Esta seção é do template PAI
		@show
		<!-- o show mostra a seção no template filho-->

		<!-- definindo seção -->
		@yield('conteudo')
	</div>
</body>
</html>

página filho -> 
<!-- herdando o template contido dentro da pasta layout -->
@extends('layout.app')

@section('titulo', 'Minha página - Filho')

<!-- seção que existe também no template pai, para não sobrescrever deve-se usar  -->
@section('barralateral')
	@parent <!-- mostra a seção definida com o mesmo no template pai sem sobrescrever um ao outro -->
	<p>Esta parte é da seção do template filho</p>
@endsection

@section('conteudo')
	<p>Este é o conteúdo do filho</p>
@endsection

utilizando component ->
<html>
<head>
	<title>Página do Bootstrap</title>
	<!-- <link rel="stylesheet" type="text/css" href="{{asset('css/app.css')}}"> -->
	<link rel="stylesheet" type="text/css" href="{{URL::to('css/app.css')}}">
</head>
<body>
	<!-- <script type="text/javascript" src="{{asset('js/app.js')}}"></script> -->
	<!-- ou -->
	@component('components.meucomponente')
		<strong>Erro: </strong> Sua mensagem de erro.
	@endcomponent
	<script type="text/javascript" src="{{URL::to('js/app.js')}}"></script>
</body>
</html>

pasta view/component/meucomponente.blade.php -> 
<div class="alert alert-primary" role="alert">
  {{$slot}}
</div>

passando parâmetros para componentes -> 
	-> no component
	<div class="alert alert-{{$tipo}}" role="alert">
	  <div class="alert-title">{{$titulo}}</div>
	  {{$slot}}
	</div>

	-> view ->
	<body>
		@component('components.meucomponente', ['tipo' => 'danger', 'titulo' => 'Erro fatal'])
			<strong>Erro: </strong> Sua mensagem de erro.
		@endcomponent

		<script type="text/javascript" src="{{URL::to('js/app.js')}}"></script>
	</body>

customizando chamadas a componentes ->
	-> app/Providers/AppServiceProvider.php -> editar ->
		namespace App\Providers;
		use Illuminate\Support\Facades\Blade;
		use Illuminate\Support\ServiceProvider;
		public function boot() {
			Blade::component('components.meucomponente', 'alerta'); //nomeando o componente
		}
	-> utilizando o componente nomeado (já na view) -> 
		@alerta(['tipo' => 'danger', 'titulo' => 'Erro fatal'])
			<strong>Erro: </strong> Sua mensagem de erro.
		@endalerta

if e empty na view ->
class ProdutoControlador extends Controller {
	public function listar() {
		$produtoss = [
			"Notebook Asus i7 16GB",
			"Mouse e teclado Microsoft USB",
			"Monitor 21 - Samsung",
			"Impressora HP",
			"Disco SSD 512GB",
		];

		$produtos = [];

		return view('/produtos', compact('produtos'));
	}
}

<body>

	@if(isset($produtos))

		@if(count($produtos) == 0)
			<h1>Nenhum produto</h1>
		@elseif (count($produtos) === 1)
			<h1>Um produto</h1>
		@else
			<h1>Temos vários produtos</h1>
		@endif

		@empty($produtos)
			<h2>Nada em produtos</h2>
		@endempty

	@else
		<h2>Variável produtos não foi passada como parâmetro</h2>
	@endif

	<script type="text/javascript" src="{{URL::to('js/app.js')}}"></script>
</body>

o método hasSection (só mostra a seção se esta existir) -> dentro do template
	@hasSection('minha_secao_produtos') //verifica a seção da view normal
	<div class="card">
		<div class="card-body">
			<h5 class="card-title">Produtos</h5>

			<p class="card-text">
				@yield('minha_secao_produtos')
			</p>
			<a href="#" class="card-link">Informações</a>
			<a href="#" class="card-link">Ajuda</a>
		</div>
	</div>
	@endif

switch case -> 
	na rota ->
		public function mostrar_opcoes() {
			return view('/mostrar_opcoes');
		}

		public function opcoes($opcao) {
			return view('opcoes', compact('opcao'));
		}

	na view ->
	@extends('layout.meulayout')

	@section('minha_secao_produtos')
		<a href="/opcoes/1" class="btn btn-primary btn-sm" role="button" aria-disable="true">Azul</a>
		<a href="/opcoes/2" class="btn btn-danger btn-sm" role="button" aria-disable="true">Vermelho</a>
		<a href="/opcoes/3" class="btn btn-success btn-sm" role="button" aria-disable="true">Verde</a>
		<a href="/opcoes/4" class="btn btn-warning btn-sm" role="button" aria-disable="true">Amarelo</a>
		<a href="/opcoes/5" class="btn btn-light btn-sm" role="button" aria-disable="true">Branco</a>
	@endsection

	@extends('layout.meulayout')

	@section('minha_secao_produtos')
		Voçê escolheu a opção:
		@if(isset($opcao))
			@switch($opcao)
				@case(1)
					<span class="badge badge-primary">Azul</span>
					@break;
				@case(2)
					<span class="badge badge-danger">Vermelho</span>
					@break;
				@case(3)
					<span class="badge badge-success">Verde</span>
					@break;
				@case(4)
					<span class="badge badge-warning">Amarelo</span>
					@break;
				@default
					<span class="badge badge-dark">Outra cor</span>
			@endswitch
		@endif
	@endsection

	no controlador ->

	public function mostrar_opcoes() {
		return view('/mostrar_opcoes');
	}

	public function opcoes($opcao) {
		return view('opcoes', compact('opcao'));
	}

for -> 
	Route::get('/loop/for/{n}', 'ProdutoControlador@loopFor');

	@for($i=0; $i<$n; $i++)
		<p> Numero {{$i}} </p>
	@endfor

foreach ->

	Route::get('/loop/foreach', 'ProdutoControlador@loopForeach');

	@foreach($produtos as $p)
		<p>Nome: {{$p}}</p>
	@endforeach

	foreach associativo ->
	Route::get('/loop/foreach', 'ProdutoControlador@loopForeach');
	public function loopForeach() {
		$produtos = [
			["id" => 1, "nome" => "computador"],
			["id" => 2, "nome" => "mouse"],
			["id" => 3, "nome" => "impressora"],
			["id" => 4, "nome" => "monitor"],
			["id" => 5, "nome" => "teclado"],
		];

		return view('foreach', compact('produtos'));
	}

	@foreach($produtos as $p)
		<p>{{$p['id']}}: {{$p['nome']}}</p>
	@endforeach

atributos dos laços ->
	@foreach($produtos as $p)
		<p>{{$p['id']}}: {{$p['nome']}}

		@if($loop->first) //verifica o primeiro elemento do array
			(primeiro)
		@endif

		@if($loop->last) //verifica o último elemento do array
			(último)
		@endif

		<span class="badge badge-secondary">
			{{$loop->index}} / {{$loop->count-1}} / {{$loop->remaining}} //verifica o índex / verifica o total de iterações/ verifica quantos faltam
		</span>
		<span class="badge badge-warning">
			{{$loop->iteration}} / {{$loop->count}} //verifica o número da iteração 
		</span>
		</p>
	@endforeach
---------------------------------------------------------------------------------
#Migrations
configurar o arquivo .env -> 
	...
	DB_CONNECTION=mysql
	DB_HOST=127.0.0.1
	DB_PORT=3306
	DB_DATABASE=vendas //conforme banco criado no phpmyadmin
	DB_USERNAME=root //usuário
	DB_PASSWORD= //senha
	...
pasta migrations -> database -> migrations
criar migration -> php artisan make:migration criar_tabela_produtos (nome do script) --create=produtos (cria a tabela produtos)
dentro da migration -> 
	 public function up()
    { 
        //cria as migrations das antigas para a mais nova (aqui cria algo)
         Schema::create('produtos', function (Blueprint $table) { //tabela criada pelo comando --create=produtos
            $table->bigIncrements('id'); //criação de campos
            $table->string('nome'); //criação de campos
			$table->float('preco'); //criação de campos
			$table->integer('estoque'); //criação de campos
            $table->timestamps();
        });
    }

     public function down()
    { 
        //serve para reverter as modificações feitas pelo up (aqui apaga algo)
        Schema::dropIfExists('produtos'); //apaga tabela
    }
criar campos da tabela -> php artisan migrate
acessar mysql pelo terminal linux -> mysql -u root -p
desfazer a última alteração -> php artisan migrate:rollback
apagar todas as tabelas e começar do zero -> php artisan migrate:fresh
resetar tudo -> php artisan migrate:reset
verifica status da migration (se foi executada ou não) -> php artisan migrate:status
atualizar uma migration -> php artisan make:migration adicionar_categoria_id_em_produto --table=categorias
atualizando dentro do arquivo da migration ->
	public function up() {

		Schema::table('produtos', function (Blueprint $table) {
			$table->unsignedBigInteger('categoria_id')->unsigned(); //criando a chave estrangeira
			$table->foreign('categoria_id')->references('id')->on('categorias'); //referenciando a chave estrangeira
		});
	}

	public function down() {
		Schema::table('produtos', function (Blueprint $table) {
			$table->dropForeign(['categoria_id']); //deletando a chave estrangeira
			$table->dropColumn(['categoria_id']); //deletando a coluna
		});
	}
---------------------------------------------------------------------------------
#Seed
preenche as tabelas do DB
criar seeder -> php artisan make:seeder CategoriasSeeder
pasta das seed -> database/seed
inserindo dados na tabela (dentro do arquivo seeder) ->
	...
	public function run() {
		DB::table('categorias')->insert([ //inserindo 4 registros na tabela categorias
			'nome' => 'Roupas',
		]);

		DB::table('categorias')->insert([
			'nome' => 'Eletrônicos',
		]);

		DB::table('categorias')->insert([
			'nome' => 'Perfumes',
		]);

		DB::table('categorias')->insert([
			'nome' => 'Móveis',
		]);
	}
	...
dentro do arquivo DatabaseSeeder.php(database/seeds) -> acrescentar a seguinte linha ->
...
public function run() {
		// $this->call(UsersTableSeeder::class);
		$this->call(CategoriasSeeder::class);
	}
...
executando a seed -> php artisan db:seed
------------------------------------------------
#Queries SQL
listar dados -> routes -> 
	use Illuminate\Support\Facades\DB;
	Route::get('/categorias', function () {
	$cats = DB::table('categorias')->get(); //lista os registros da tabela categorias
	foreach ($cats as $c) {
		echo "id: " . $c->id . "; ";
		echo "nome: " . $c->nome . "<br /> ";
	}

	echo "<hr>";

	$nomes = DB::table('categorias')->pluck('nome'); //retorna somente os registros da coluna nome da tabela categorias
	foreach ($nomes as $nome) {
		echo "$nome <br />";
	}
});

cláusula where -> 
	...
	$cats = DB::table('categorias')->where('id', 1)->get(); //lista os registros da tabela quando o id for igual a 1 (Where)
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}

		echo "<hr>";

		$cat = DB::table('categorias')->where('id', 1)->first(); //lista um único registro quando o id for igual a 1 (pega o primeiro resultado)
		echo "id: " . $cat->id . "; ";
		echo "nome: " . $cat->nome . "<br /> ";

		echo "<hr>";

		echo "</p>Retorna um array utilizando like</p>";
		$cats = DB::table('categorias')->where('nome', 'like', '%o%')->get(); //utilizando o Like para buscar registros (pesquisar texto)
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}

		echo "</p>Sentenças lógicas (where/orwhere)</p>";
		$cats = DB::table('categorias')->where('id', 1)->orwhere('id', 2)->get(); //utilizando o where/orwhere para buscar registros (ou um ou outro)
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}

		echo "</p>Intervalos (whereBetween)</p>";
		$cats = DB::table('categorias')->whereBetween('id', [1, 3])->get(); //utilizando o whereBetween para buscar registros dentro de intervalo
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}

		echo "</p>Intervalos Negação (whereNotBetween)</p>";
		$cats = DB::table('categorias')->whereNotBetween('id', [1, 3])->get(); //utilizando o whereNotBetween para buscar registros diferente do intervalo
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}

		echo "</p>Conjuntos (whereIn)</p>";
		$cats = DB::table('categorias')->whereIn('id', [1, 3, 4])->get(); //lista os registros cujos id são 1,3 e 4 (whereIn)
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}

		echo "</p>Conjuntos Negação (whereNotIn)</p>";
		$cats = DB::table('categorias')->whereNotIn('id', [1, 3, 4])->get(); //lista os registros cujos id são diferentes de 1,3 e 4 (whereNotIn)
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}

		echo "</p>Comparações</p>";
		$cats = DB::table('categorias')->where('id', '>', 3)->get(); //lista os registros cujos id é maior que 3 (where >)
		// $cats = DB::table('categorias')->where('id', '<', 3)->get(); //lista os registros cujos id é menor que 3
		// $cats = DB::table('categorias')->where('id', '<=', 3)->get(); //lista os registros cujos id é menor e igual que 3
		// $cats = DB::table('categorias')->where('id', '!=', 3)->get(); //lista os registros cujos id é diferente de 3
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}

		// echo "</p>Comparando Datas(whereDate)</p>";
		// $cats = DB::table('produtos')->whereDate('data_cadastro', '2018-12-15')->get(); //comparando Datas
		// // Produto::whereDate('data_cadastro', '2018-12-15');

		echo "</p>Where (and)</p>";
		$cats = DB::table('categorias')->where([ //listando dados quando id for igual a 1 AND nome igual a Roupas
			['id', 1],
			['nome', 'Roupas'],
		])->get();
		foreach ($cats as $c) {
			echo "id: " . $c->id . "; ";
			echo "nome: " . $c->nome . "<br /> ";
		}
		...
	orderBy -> 
	...
	echo "</p>Ordenando por nome</p>";
		$cats = DB::table('categorias')->orderBy('nome')->get(); //lista todos os dados ordenado por nome (orderBy)
		foreach ($cats as $cat) {
			echo "id: " . $cat->id . "; ";
			echo "nome: " . $cat->nome . "<br /> ";
		}

		echo "</p>Ordenando por nome (decrescente)</p>";
		$cats = DB::table('categorias')->orderBy('nome', 'desc')->get(); //lista todos os dados em ordem decrescente (orderBy, desc)
		foreach ($cats as $cat) {
			echo "id: " . $cat->id . "; ";
			echo "nome: " . $cat->nome . "<br /> ";
		}
	...

inserir dados -> 
	...
	Route::get('/novascategorias', function () {
		// DB::table('categorias')->insert([           //inserindo registros
		//     ['nome' => 'Carro'],
		//     ['nome' => 'Informática'],
		//     ['nome' => 'Cozinha'],
		// ]);

		$id = DB::table('categorias')->insertGetId( //inserindo um único registro e pegando o seu id
			['nome' => 'Carros']
		);

		echo "Novo ID = $id <br />";
	});
	...

atualizando dados -> 
	...
	Route::get('/atualizandocategorias', function () {
	$cat = DB::table('categorias')->where('id', 1)->first();
	echo "<p>Antes da atualização</p>";
	echo "id: " . $cat->id . "; ";
	echo "nome: " . $cat->nome . "<br /> ";

	DB::table('categorias')->where('id', 1)->update([ //atualizando registros
		'nome' => 'Roupas infantis',
	]);

	$cat = DB::table('categorias')->where('id', 1)->first();
	echo "<p>Depois da atualização</p>";
	echo "id: " . $cat->id . "; ";
	echo "nome: " . $cat->nome . "<br /> ";

	});
	...
apagando dados -> 
Route::get('/removendocategorias', function () {

	echo "<p>Antes da remoção</p>";
	$cats = DB::table('categorias')->get();
	foreach ($cats as $cat) {
		echo "id: " . $cat->id . "; ";
		echo "nome: " . $cat->nome . "<br /> ";
	}

	echo "<hr />";

	DB::table('categorias')->where('id', 2)->delete();

	echo "<p>Depois da remoção</p>";
	$cats = DB::table('categorias')->get();
	foreach ($cats as $cat) {
		echo "id: " . $cat->id . "; ";
		echo "nome: " . $cat->nome . "<br /> ";
	}

});
-------------------------------------------------------------------------------
#Eloquent / ORM
criando modelo + migration -> php artisan make:model Categoria -m
listando dados -> 
use App\Categoria;
...
$categorias = Categoria::all(); //listar dados 
	foreach ($categorias as $c) {
		echo "id:" . $c->id . ', ';
		echo "nome: " . $c->nome . '<br />';
	}
...
apagando dados ->
use App\Categoria;
...
$cat = New Categoria();
$cat->nome = $nome;
$cat->save(); //salvar dados
return redirect('/');
...
recuperando registro por id -> 
use App\Categoria;
...
$cat = Categoria::find($id); //seleciona registro por id
	// $cat = Categoria::findOrFail($id); //caso queira mostrar a página de erro do Laravel (Not Found 404)
	if (isset($cat)) {
		echo "id:" . $cat->id . ', ';
		echo "nome: " . $cat->nome . '<br />';
	} else {
		echo "<h1>Categoria nao encontrada</h1>";
	}
...

atualizando registro -> 
...
	$cat = Categoria::find($id); //seleciona dado por id
	if (isset($cat)) {
		$cat->nome = $nome;
		$cat->save();
		return redirect('/');
	} else {
		echo "<h1>Categoria nao encontrada</h1>";
	}
...
removendo registro ->
...
	$cat = Categoria::find($id); //seleciona registro por id
	if (isset($cat)) {
		$cat->delete(); //deleta registro
		return redirect('/');
	} else {
		echo "<h1>Categoria nao encontrada</h1>";
	}
...

cláusula where -> 
...
Route::get('/categoriapornome/{nome}', function ($nome) {
	$categorias = Categoria::where('nome', $nome)->get(); //filtrando dados com Where (=)
	foreach ($categorias as $c) {
		echo "id:" . $c->id . ', ';
		echo "nome: " . $c->nome . '<br />';
	}
});

Route::get('/categoriaidmaiorque/{id}', function ($id) {
	$categorias = Categoria::where('id', '>=', $id)->get(); //filtrando dados com Where por meio de comparação
	foreach ($categorias as $c) {
		echo "id:" . $c->id . ', ';
		echo "nome: " . $c->nome . '<br />';
	}
	$count = Categoria::where('id', '>', $id)->count(); //realiza a contagem de elementos retornados com filtro
	$count = Categoria::count(); //realiza a contagem de elementos retornados
	echo "<h1>Count: $count </h1>";

	$max = Categoria::where('id', '>', $id)->max('id'); //pega o valor máximo retornado, no caso o id
	echo "<h1>Máximo: $max </h1>";
});

Route::get('/ids123/{id}', function ($id) {
	$categorias = Categoria::find([1, 2, 3]); //retornando registros que possuem o id igual a 1,2,3
	// $categorias = Categoria::whereIn('id', [1, 2, 3])->get(); //parecido com o find()
	foreach ($categorias as $c) {
		echo "id:" . $c->id . ', ';
		echo "nome: " . $c->nome . '<br />';
	}
});
...
-----------------------------------------------------------------------
#Soft Deletes
soft deletes (não é deletado de fato) -> dentro da migration -> 
...
public function up() {
		Schema::create('categorias', function (Blueprint $table) {
			$table->bigIncrements('id');
			$table->string('nome');
			$table->softDeletes(); //criando campo que registra se um arquivo foi deletado (na tabela é criado o campo 'deleted_at')
			$table->timestamps();
		});
	}
...

executa o comando -> php artisan migrate (para atualizar a tabela)
dentro do arquivo model (app/NomeDoModel.php) -> 

namespace App;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\softDeletes; //incluir esta linha

class Categoria extends Model {
	use softDeletes; //incluir esta linha
	protected $dates = ['deleted_at'];  	//incluir esta linha
}

para deletar -> normal, como se fosse deletar sem o sofdelete
mostrar todos os registros, inclusive os apagados -> 
	...
	$categorias = Categoria::withTrashed()->get(); //listar todos os registros, inclusive os que foram apagados
		foreach ($categorias as $c) {
			echo "id:" . $c->id . ', ';
			echo "nome: " . $c->nome;
			if ($c->trashed()) {    //verifica se um elemento foi apagado
				echo " (apagado) <br />";
			} else {
				echo '<br>';
			}
		}
	...
buscar registros apagados -> 
	// $categorias = Categoria::withTrashed()->find($id); //lista o registro que foi apagado por id
	$cat = Categoria::withTrashed()->where('id', $id)->get()->first(); //lista o registro que foi apagado por id (outra forma)
	if (isset($cat)) {
		echo "id: " . $cat->id . ', ';
		echo "nome: " . $cat->nome . '<br>';
	} else {
		echo "<h1>Categoria nao encontrada</h1>";
	}

	$categorias = Categoria::onlyTrashed()->get(); //lista somente os registros que foram apagados
	foreach ($categorias as $c) {
		echo "id:" . $c->id . ', ';
		echo "nome: " . $c->nome;
		if ($c->trashed()) { //verifica se um elemento foi apagado
			echo " (apagado) <br />";
		} else {
			echo '<br>';
		}
	}

restaurando registros apagados ->
...
$cat = Categoria::withTrashed()->find($id); //lista o registro que foi apagado por id (outra forma)
	if (isset($cat)) {
		$cat->restore(); //restaura o registro deletado
		echo "Categoria restaurada: " . $cat->id . '<br />';
		echo "<a href=\"/\">Listar todas</a>";
	} else {
		echo "<h1>Categoria nao encontrada</h1>";
	}
...

apagando registros permanentemente -> 
...
$cat = Categoria::withTrashed()->find($id); //lista o registro que foi apagado por id (outra forma)
if (isset($cat)) {
	$cat->forceDelete(); //deleta o registro permanentemente independente do softdelete estar habilitado
	return redirect('/todas');
} else {
	echo "<h1>Categoria nao encontrada</h1>";
}
...
-----------------------------------------------------
#Tinker 
uma espécie de terminal do laravel -> php artisan tinker -> utilizado para executar códigos de manipulação de registros do DB

-----------------------------------------------------------------------------
#Validação
campo requerido ->
(controlador)
public function store(Request $request) {

		$request->validate([
			'nome' => 'required', //o campo é requerido
		]);

		$cliente = new Cliente();
		$cliente->nome = $request->input('nome');
		$cliente->idade = $request->input('idade');
		$cliente->endereco = $request->input('endereco');
		$cliente->email = $request->input('email');
		$cliente->save();
	}
(view)
<!-- se existir qualquer erro -->
	@if($errors->any())
	<div class="card-footer">
		<!-- pegar cada erro de validação -->
		@foreach($errors->all() as $error)
		<div class="alert alert-danger" role="alert">
			{{$error}}
		</div>
		@endforeach
	</div>
	@endif

min/máx ->
...
public function store(Request $request) {
	$request->validate([
		'nome' => 'required|min:5|max:10', //o campo é requerido / valor mínimo / valor máximo
	]);
...

unique -> 
...
public function store(Request $request) {
	$request->validate([
		'nome' => 'required|min:5|max:10|unique:clientes', //o campo é requerido / valor mínimo / valor máximo / valor único (unique:nomeTabela)
	]);
...

multicampos -> 
...
public function store(Request $request) {
	$request->validate([
		//o campo é requerido / valor mínimo / valor máximo / valor único (unique:nomeTabela)
		'nome' => 'required|min:5|max:10|unique:clientes',
		'idade' => 'required|',
		'endereco' => 'required|min:5',
		'email' => 'requerid|email', //verifica se um campo é do tipo email
	]);
...

email -> 
..
public function store(Request $request) {
	$request->validate([
		//o campo é requerido / valor mínimo / valor máximo / valor único (unique:nomeTabela)
		'email' => 'requerid|email', //verifica se um campo é do tipo email
	]);
...

customizar mensagem de erro -> 
...
/* Uma opção de customizar mensagem
$regras = [
	'nome' => 'required|min:5|max:10|unique:clientes',
	'idade' => 'required|',
	'endereco' => 'required|min:5',
	'email' => 'required|email',
];

$mensagens = [
	'required' => 'O atributo :attribute não pode estar em branco.', //criando mensagem genérica para o campo required
	'nome.required' => 'O nome é requerido',
	'nome.min' => 'É necessário no mínimo três caracteres no nome',
	'email.required' => 'Digite um endereço de email válido',
];

$request->validate($regras, $mensagens);

	/* Outra opção de customizar mensagem

	    $mensagens = [
	    'nome.required' => 'O nome é requerido',
	    'nome.min' => 'É necessário no mínimo três caracteres no nome',
	    'email.required' => 'Digite um endereço de email válido',
	    ];

	    $request->validate([
	    //o campo é requerido / valor mínimo / valor máximo / valor único (unique:nomeTabela)
	    'nome' => 'required|min:5|max:10|unique:clientes',
	    'idade' => 'required|',
	    'endereco' => 'required|min:5',
	    'email' => 'required|email', //verifica se um campo é do tipo email
	    ], $mensagens);
	*/

customizar mensagem campo a campo -> 
...
<form action="/cliente" method="POST">
	@csrf
	<div class="form-group">
		<label for="nome">Nome do Cliente</label>
		<input type="text" name="nome" id="nome" placeholder="Nome do cliente" class="form-control {{$errors->has('nome') ? 'is-invalid' : ''}}" value="{{old('nome')}}"> //classe para o input
		@if($errors->has('nome')) //verifica se há erro na validação
		<div class="invalid-feedback">
			{{$errors->first('nome')}} //retorna o primeiro erro
		</div>
		@endif
	</div>
	<div class="form-group">
		<label for="idade">Idade do Cliente</label>
		<input type="text" name="idade" id="idade" placeholder="Idade do cliente" class="form-control {{$errors->has('idade') ? 'is-invalid' : ''}}">
		@if($errors->has('idade'))
		<div class="invalid-feedback">
			{{$errors->first('idade')}}
		</div>
		@endif
	</div>
	<div class="form-group">
		<label for="endereco">Endereço do Cliente</label>
		<input type="text" name="endereco" id="endereco" placeholder="endereço do cliente" class="form-control {{$errors->has('endereco') ? 'is-invalid' : ''}}">
		@if($errors->has('endereco'))
		<div class="invalid-feedback">
			{{$errors->first('endereco')}}
		</div>
		@endif
	</div>
	<div class="form-group">
		<label for="email">E-mail do Cliente</label>
		<input type="text" name="email" id="email" placeholder="E-mail do cliente" class="form-control {{$errors->has('email') ? 'is-invalid' : ''}}">
		@if($errors->has('email'))
		<div class="invalid-feedback">
			{{$errors->first('email')}}
		</div>
		@endif
	</div>
	<button type="submit" class="btn btn-primary">Salvar</button>
	<button type="cancel" class="btn btn-warning">Cancelar</button>
</form>

...
mantendo as informações no formulário ->
<input type="text" name="nome" id="nome" placeholder="Nome do cliente" class="form-control {{$errors->has('nome') ? 'is-invalid' : ''}}" value="{{old('nome')}}"> //value="{{old('nome')}}
--------------------------------------------------------------------------
#Relacionamento-Um-para-Um
na migration da tabela principal ->
...
public function up() {
	Schema::create('clientes', function (Blueprint $table) {
		$table->bigIncrements('id');
		$table->string('nome');
		$table->string('telefone');
		$table->timestamps();
	});
}
...

na migration da tabela secundária ->
...
public function up() {
		Schema::create('enderecos', function (Blueprint $table) {
			$table->Biginteger('cliente_id')->unsigned(); 					//cria o campo
			$table->foreign('cliente_id')->references('id')->on('clientes'); //cria a chave estrangeira
			$table->primary('cliente_id'); 									//cria o campo acima como primário
			$table->string('rua');
			$table->string('numero');
			$table->string('bairro');
			$table->string('cidade');
			$table->string('uf');
			$table->string('cep');
			$table->timestamps();
		});
	}
...
uma forma de relacionamento -> no controller ->
...
	$clientes = Clientes::all();
	foreach ($clientes as $c) {
		echo '<p>Id:' . $c->id . '</p>';
		echo '<p>Nome:' . $c->nome . '</p>';
		echo '<p>Telefone:' . $c->telefone . '</p>';
		$e = Enderecos::where('cliente_id', $c->id)->first(); //é uma solução, mas não a recomendada
		echo '<p>Rua:' . $e->rua . '</p>';
		echo '<p>Número:' . $e->numero . '</p>';
		echo '<p>Bairro:' . $e->bairro . '</p>';
		echo '<p>Cidade:' . $e->cidade . '</p>';
		echo '<p>UF:' . $e->uf . '</p>';
		echo '<p>CEP:' . $e->cep . '</p>';
		echo '<hr>';
	}

	$enderecos = Enderecos::all();
	foreach ($enderecos as $e) {
		echo '<p>Rua:' . $e->rua . '</p>';
		echo '<p>Número:' . $e->numero . '</p>';
		echo '<p>Bairro:' . $e->bairro . '</p>';
		echo '<p>Cidade:' . $e->cidade . '</p>';
		echo '<p>UF:' . $e->uf . '</p>';
		echo '<p>CEP:' . $e->cep . '</p>';
		echo '<hr>';
	}
...

a melhor forma de relacionamento -> no Model cuja tabela é a principal -> hasOne -> tabela principal para estrangeira

	namespace App;

	use Illuminate\Database\Eloquent\Model;

	class Clientes extends Model {
		public function enderecos() {
			return $this->hasOne('App\Enderecos'); //relacionamento um-para-um
		}
	}

	no controller ->
	...
	$clientes = Clientes::all();
		foreach ($clientes as $c) {
			echo '<p>Id:' . $c->id . '</p>';
			echo '<p>Nome:' . $c->nome . '</p>';
			echo '<p>Telefone:' . $c->telefone . '</p>';
			echo '<p>Rua:' . $c->enderecos->rua . '</p>'; //forma correta de relacionar um-para-um
			echo '<p>Número:' . $c->enderecos->numero . '</p>';
			echo '<p>Bairro:' . $c->enderecos->bairro . '</p>';
			echo '<p>Cidade:' . $c->enderecos->cidade . '</p>';
			echo '<p>UF:' . $c->enderecos->uf . '</p>';
			echo '<p>CEP:' . $c->enderecos->cep . '</p>';
			echo '<hr>';
		}
	...

	caso a primary key da tabela principal não seja 'id' ->

	namespace App;

	use Illuminate\Database\Eloquent\Model;

	class Clientes extends Model {
		public function enderecos() {
			// caso o campo primary key da tabela endereços não fosse 'id', 
			// o primeiro refere-se ao nome do campo da tabela estrangeira e o segundo ao 
			// nome do campo da própria tabela (enderecos)
			return $this->hasOne('App\Enderecos', 'clientes_id', 'id'); 
		}
	}

a melhor forma de relacionamento -> no Model cuja tabela é a principal -> belongsTo -> tabela estrangeira para principal
	-> no model ->
	...
	namespace App;

	use Illuminate\Database\Eloquent\Model;

	class Enderecos extends Model {
		public function clientes() {
			return $this->belongsTo('App\Clientes', 'clientes_id', 'id'); //tabela estrangeira para a tabela principal
		}
	}
	...

	-> no controller ->
	...
	$enderecos = Enderecos::all();
	foreach ($enderecos as $e) {
		echo '<p>Rua:' . $e->rua . '</p>';

		echo '<p>Nome:' . $e->clientes->nome . '</p>'; //tabela estrangeira para tabela principal
		echo '<p>Telefone:' . $e->clientes->telefone . '</p>'; //tabela estrangeira para tabela principal

		echo '<p>Número:' . $e->numero . '</p>';
		echo '<p>Bairro:' . $e->bairro . '</p>';
		echo '<p>Cidade:' . $e->cidade . '</p>';
		echo '<p>UF:' . $e->uf . '</p>';
		echo '<p>CEP:' . $e->cep . '</p>';
		echo '<hr>';
	}
	...

inserindo registros através dos relacionamentos -> no controller ->
	...
	$c = new Clientes();
	$c->nome = 'Francisco';
	$c->telefone = '666-5555';
	$c->save();

	$e = new Enderecos();
	$e->rua = 'José Bonifácio';
	$e->numero = 44;
	$e->bairro = 'Maiobão';
	$e->cidade = 'São José';
	$e->uf = 'MA';
	$e->cep = '65110-000';

	$e->clientes_id = $c->id; //uma forma de inserir dados em tabelas relacionadas
	$c->enderecos()->save($e); //forma ideal de relacionar
	...

Eager Loading vs Lazy Loading -> no controller -> 
	...
	// $clientes = Clientes::all(); // método Lazy loading - não carrega todos os dados (método padrão)

	//método Eager Loading(dentro de with() coloca-se o nome do outro relacionamento)
	$clientes = Clientes::with(['enderecos'])->get();
	return $clientes->toJson();
	...
---------------------------------------------------
#Relacionamento-Um-para-Muitos
no model filho -> 
	...
	namespace App;

	use Illuminate\Database\Eloquent\Model;

	class Produto extends Model {
		public function categoria() {
			return $this->belongsTo('App\Categoria'); //relacionamento filho-pai
		}
	}
	...
no controller ->
	...
	$pro = Produto::all();
		if (count($pro) === 0) {
			echo "<h4>Você não possui nenhum produto cadastrada</h4>";
		} else {
			echo "<table>";
			echo "<thead><tr><td>Nome</td><td>Estoque</td><td>Preco</td><td>Categoria</td></tr></thead>";
			foreach ($pro as $p) {
				echo "<tr>";
				echo "<td>" . $p->nome . "</td>";
				echo "<td>" . $p->estoque . "</td>";
				echo "<td>" . $p->preco . "</td>";
				echo "<td>" . $p->categoria->nome . "</td>"; //relacionado entre as tabelas (filha-pai)
				echo "</tr>";
			}
		}
	...

no model pai -> 
...
namespace App;

use Illuminate\Database\Eloquent\Model;

class Categoria extends Model {
	public function produtos() {
		return $this->hasMany('App\Produto'); //relacionamento pai-filho
	}
}
...

no controller -> 
...
$cat = Categoria::all();
	if (count($cat) === 0) {
		echo "<h4>Você não possui nenhuma categoria cadastrada</h4>";
	} else {
		foreach ($cat as $c) {
			echo "<p>" . $c->id . ' - ' . $c->nome . "</p>";

			$produtos = $c->produtos; //relacionamento pai-filho
			echo "<ul>";
			foreach ($produtos as $p) {
				echo "<li>" . $p->nome . "</li>";
			}
			echo "</ul>";
		}
	}
...

Eager Loading -> no controller ->
...
$cats = Categoria::with('produtos')->get();
	return $cats->toJson();
...

Criando e removendo associações -> filho-pai
	...
	Route::get('/adicionarproduto', function () {
		/* Uma forma de incluir registro em tabelas relacionadas (associar registros)
			    $p = new Produto();
			    $p->nome = "Meu novo produto";
			    $p->estoque = 10;
			    $p->preco = 100;
			    $p->categoria_id = 1; //uma forma de incluir registro em tabela relacionada
			    $p->save();
		*/

		$c = Categoria::find(1);
		$p = new Produto();
		$p->nome = "Meu novo produto 2";
		$p->estoque = 10;
		$p->preco = 100;
		$p->categoria()->associate($c); //outra forma (elegante) de incluir registro em tabela
		$p->save();
		return $p->toJson();
	});

	Route::get('/removerprodutocategoria', function () {

		$p = Produto::find(1);
		if (isset($p)) {
			$p->categoria()->dissociate(); //disassociar registros entre tabelas
			$p->save();
			return $p->toJson();
		}
		return '';
	});
	...

Save-> pai-filho -> 
	...
	Route::get('/adicionarproduto/{catid}', function () {
		//pai-filho
		$c = Categoria::with('produtos')->find(1); //como se fosse join por id

		$p = new Produto();
		$p->nome = "Meu novo produto 3";
		$p->estoque = 40;
		$p->preco = 500;

		if (isset($c)) {
			$c->produtos()->save($p); //outra forma de saver registros em tabelas relacionadas
		}

		$c->load('produtos'); //atualiza os registros do relacionamento
		return $c->toJson();
	});
	...
------------------------------------------
#Relacionamento-Muitos-para-Muitos
tabela 1 migration ->
public function up() {
		Schema::create('desenvolvedores', function (Blueprint $table) {
			$table->bigIncrements('id');
			$table->string('nome');
			$table->string('campo');
			$table->timestamps();
		});
	}

tabela 2 migration -> 
public function up() {
		Schema::create('projetos', function (Blueprint $table) {
			$table->bigIncrements('id');
			$table->string('nome');
			$table->integer('estimativa_horas');
			$table->timestamps();
		});
	}

tabela 3  migration-> junção -> 
public function up() {
		Schema::create('alocacoes', function (Blueprint $table) {
			$table->bigInteger('desenvolvedor_id')->unsigned();
			$table->foreign('desenvolvedor_id')->references('id')->on('desenvolvedores');
			$table->bigInteger('projeto_id')->unsigned();
			$table->foreign('projeto_id')->references('id')->on('projetos');
			$table->timestamps();
			$table->integer('horas_semanais');
			$table->primary(['projeto_id', 'desenvolvedor_id']);
		});
	}

relacionando as tabelas -> 
	-> no model ->
	...
	namespace App;

	use Illuminate\Database\Eloquent\Model;

	class Desenvolvedor extends Model {
		protected $table = 'desenvolvedores'; //incluir linha para fugir do padrão de nomenclarura de nome de tabelas

		public function projetos() {
			return $this->belongsToMany('App\Projeto', 'alocacoes'); //relação de muitos para muitos
		}
	}
	...

	-> no controller ->
	...
	$desenvolvedor = Desenvolvedor::with('projetos')->get(); //relação de muitos para muitos

	foreach ($desenvolvedor as $d) {
		echo "<p>Nome do Desenvolvedor: " . $d->nome . "</p>";
		echo "<p>Cargo: " . $d->cargo . "</p>";
		if (count($d->projetos) > 0) { //fazendo o relacionamento entre as tabelas
			echo "Projetos: <br>";
			echo "<ul>";
			foreach ($d->projetos as $p) {
				echo "<li>";
				echo "Nome: " . $p->nome . "|";
				echo "Estimativa de Horas: " . $p->estimativa_horas;
				echo "</li>";
			}
			echo "</ul>";
		}

		echo "<hr>";
	}
	...

obtendo campos pivôs (tabelas do meio) -> pivo refere-se aos dados da tabela do meio ->
	no model -> 
	...
	namespace App;

	use Illuminate\Database\Eloquent\Model;

	class Desenvolvedor extends Model {
		protected $table = 'desenvolvedores'; //incluir linha para fugir do padrão de nomenclarura de nome de tabelas

		public function projetos() {
			return $this->belongsToMany('App\Projeto', 'alocacoes')->withPivot('horas_semanais'); //relação de muitos para muitos e retornando os campos da tabela  pivô (faz a ligação entre as duas)
		}
	}
	...

	no controller -> 
	...
	$desenvolvedor = Desenvolvedor::with('projetos')->get(); //relação de muitos para muitos

	foreach ($desenvolvedor as $d) {
		echo "<p>Nome do Desenvolvedor: " . $d->nome . "</p>";
		echo "<p>Cargo: " . $d->cargo . "</p>";
		if (count($d->projetos) > 0) {
			//fazendo o relacionamento entre as tabelas
			echo "Projetos: <br>";
			echo "<ul>";
			foreach ($d->projetos as $p) {
				echo "<li>";
				echo "Nome: " . $p->nome . " | ";
				echo "Estimativa de Horas: " . $p->estimativa_horas . " | ";
				echo "Horas trabalhadas: " . $p->pivot->horas_semanais; //acessando os campos da tabela pivo (une as duas)
				echo "</li>";
			}
			echo "</ul>";
		}

		echo "<hr>";
	}

	return $desenvolvedor->toJson();
	...

alocando registro de uma tabela a outra ->
	...
	$proj = Projeto::find(4);
		if (isset($proj)) {
			$proj->desenvolvedores()->attach(1, ['horas_semanais' => 50]); //alocando um registro de uma tabela a outra
			$proj->desenvolvedores()->attach([ //alocando vários registros de uma tabela a outra
				2 => ['horas_semanais' => 50],
				3 => ['horas_semanais' => 60],
			]);
		}
	...

desalocando registro entre tabelas ->
	...
	Route::get('/desalocar', function () {
	$proj = Projeto::find(4);
	if (isset($proj)) {
		$proj->desenvolvedores()->detach([1, 2, 3]); //desalocando vários relacionamentos entre as tabelas
		// $proj->desenvolvedores()->detach(1); //desalocando um único relacionamento entre as tabelas
		// $proj->desenvolvedores()->detach(2);
		// $proj->desenvolvedores()->detach(3);
		}
	});
...
-----------------------------------------------
#deletar registros em cascata em relacionamentos
no campo da migration (tabela filha ) ->
	...
	$table->foreign('venda_id')->references('id')->on('vendas')->onDelete('cascade'); //deleta em cascata
	...

no controller ->
...
$c = Desenvolvedor::find(2);
$c->projetos()->delete();
...
------------------------------------------------------
#Middlewares

receptar requisiçõe http

local das middlewares -> app/Http/Middleware

criar middlewares -> php artisan make:middleware NomeDoMiddlweare 
	-> na rota ->
	use App\Http\Middleware\PrimeiroMiddleware;

	//antes de chamar o controlador deve passar pelo middleware 'PrimeiroMiddleware'
	Route::get('/usuario', 'UsuarioControlador@index')->middleware(PrimeiroMiddleware::class);


	-> na middleware -> 
	namespace App\Http\Middleware;

	use Closure;
	use Log; //usa a classe Log

	class PrimeiroMiddleware {

		public function handle($request, Closure $next) {
			Log::debug('passou pelo middleware'); //registra log
			return $next($request);
		}
	}

salvar informação no debug / log -> 

	use Closure;
	use Log; 		//usa a classe Log

	class PrimeiroMiddleware {

		public function handle($request, Closure $next) {
			Log::debug('passou pelo middleware'); 		//registra log
			return $next($request);
		}
	}
	...
	-> o arquivo de log fica em -> storage -> logs ->

registrando nome para a middleware -> 
	-> arquivo app/Http/Kernel.php ->
	...
		protected $routeMiddleware = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'bindings' => \Illuminate\Routing\Middleware\SubstituteBindings::class,
        'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
        'can' => \Illuminate\Auth\Middleware\Authorize::class,
        'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
        'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
        'primeiro' => \App\Http\Middleware\PrimeiroMiddleware::class //cria o nome e o caminho para middleware
    ];
	...

	-> na rota ->
	use App\Http\Middleware\PrimeiroMiddleware;

	Route::get('/usuario', 'UsuarioControlador@index')->middleware('primeiro'); //aqui é usado somente o nome e não o caminho

chamando middleware pelo construtor do controlador ->
	
	na rota ->
	use App\Http\Middleware\PrimeiroMiddleware;
	Route::get('/usuario', 'UsuarioControlador@index'); //aqui no caso a middleware será chamada dentro do controlador

	no controller -> 
	namespace App\Http\Controllers;

	class UsuarioControlador extends Controller {

		public function __construct() {
			$this->middleware('primeiro'); //utilizando a middleware dentro do controlador
		}


		public function index() {
			return '<h3>Lista de usuários</h3>' .
				'<ul>' .
				'<li>Joao</li>' .
				'<li>Maria</li>' .
				'<li>José</li>' .
				'<li>Marcos</li>' .
				'</ul>';
		}
	}

aplicando middleware a todas as rotas ->
	-> no arquivo app/Http/Kernel.php ->
	...
	 protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            // \Illuminate\Session\Middleware\AuthenticateSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,

            \App\Http\Middleware\PrimeiroMiddleware::class //criando middleware para todos as rotas (routes/web.php)
        ],

        'api' => [
            'throttle:60,1',
            'bindings',
        ],
    ];
    ...

    -> na rota ->
    //aqui no caso a middleware será chamada automaticamente, pois foi definida no arquivo app/Http/Kernel.php
	Route::get('/usuario', 'UsuarioControlador@index'); 


adicionando e utlizando várias middlewares -> 
	-> crie um novo middleware -> php artisan make:middleware SegundoMiddleware

	-> arquivo kernel.php (nomeando) -> 
	...
	protected $routeMiddleware = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'bindings' => \Illuminate\Routing\Middleware\SubstituteBindings::class,
        'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
        'can' => \Illuminate\Auth\Middleware\Authorize::class,
        'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
        'signed' => \Illuminate\Routing\Middleware\ValidateSignature::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
        'primeiro' => \App\Http\Middleware\PrimeiroMiddleware::class, //cria o nome e o caminho para middleware
        'segundo' => \App\Http\Middleware\SegundoMiddleware::class //cria o nome e o caminho para middleware
    ];
	...

	-> na rota -> 
	// utilizando vários middlewares 
	Route::get('/usuario', 'UsuarioControlador@index')->middleware('primeiro', 'segundo'); 

parar a cadeia de chamada de middleware -> dentro da middleware ->
	namespace App\Http\Middleware;

	use Closure;
	use Log;

	class PrimeiroMiddleware {

		public function handle($request, Closure $next) {
			Log::debug('passou pelo primeiro middleware'); //registra log
			// return $next($request); //o $next iria chamar o próximo middleware, conforme arquivo Kernel.php
	        return response('parando a cadeia de chamada'); //caso queira que não seja chamada a próxima middleware
		}
	}

passando parâmetros ->
	cria a middleware (kernel.php ) ->
	... 
	'terceiro' => \App\Http\Middleware\TerceiroMiddleware::class //cria o nome e o caminho para middleware
	...

	na middleware ->
	...
	public function handle($request, Closure $next, $nome, $idade) //passando parâmetro para a middleware
    {
        Log::debug("Passou pela terceira middleware [nome = $nome, $idade]");  //passando parâmetro para a middleware
        return $next($request);
    }
    ...

    na rota ->
    ...
    Route::get('/terceiro', function(){
		return 'Passou pelo terceiro middleware';
	})->middleware('terceiro: João, 20'); 
    ...

lógica de execução das middlewares -> tudo o que estiver antes do $next($request); será executado antes de chegar na aplicação/controlador
								  -> depois do $next($request); a aplicação já tratou a requisição e retornou a resposta


middleware Login -> 
		...
		Route::get('/produtos', 'ProdutoControlador@index');

		Route::get('/negado', function(){
			return 'Acesso Negado. Você precisa estar logado para acessar esta página';
		})->name('negado');

		Route::get('/negadologin', function(){
			return 'Prezado usuário, você precisa ser administrador para acessar este conteúdo.';
		})->name('negadologin');

		Route::post('/login', function(Request $req){
			$login_ok = false;
			$admin = false;

			// criando usuários e senhas para teste de login
			switch ($req->input('user')) {
				case 'Joao':
					$login_ok = $req->input('passwd') === 'senhajoao';
					$admin = true;
					break;
				
				case 'Maria':
					$login_ok = $req->input('passwd') === 'senhamaria';
					break;

				default:
					$login_ok = false;
			}

			// verificando se os dados do usuário estão corretos
			if ($login_ok) {
				//criando a sessão para o usuário LOGIN
				$login = ['user' => $req->input('user'), 'admin' => $admin]; //salvando o nome do usuário e verificando se ele é admin em uma variável
				$req->session()->put('login', $login); //salvando na sessão o nome do usuário e se este é admin (LOGANDO)
				return response('Login Ok', 200);
			}else {
				$req->session()->flush(); //apaga todos os dados da sessão
				return response('Erro no login', 404);
			}
		});

		// LOGOUT
		Route::get('/logout', function(Request $req){
			$req->session()->flush(); //deslogando o usuário
			return response('Deslogado com sucesso', 200);
		});
		...


	-> no controller ->
	...
	namespace App\Http\Controllers;

	use Illuminate\Http\Request;

	class ProdutoControlador extends Controller
	{

		public function __construct(){
			$this->middleware(\App\Http\Middleware\ProdutoAdmin::class); //chamando a middleware que verifica a sessão
		}

		private $produtos = ['Televisao 40', 'Notebook Acer', 'Impressora HP', 'HD externo'];

	    public function index() {
	    	echo "<h3>Produtos</h3>";
	    	echo "<ol>";
	    	foreach ($this->produtos as $p) {
	    		echo "<li>" . $p . "</li>";
	    	}
	    	echo "</ol>";
	    }
	}
	...

	-> na middleware ->

	namespace App\Http\Middleware;

	use Closure;

	class ProdutoAdmin
	{
	  
	    public function handle($request, Closure $next)
	    {
	        if ($request->session()->exists('login')) { //verificando se a sessão do usuário existe
	            $login = $request->session()->get('login');
	            if ($login['admin']) {
	                return $next($request);
	            }else{
	                return redirect()->route('negadologin');
	            }
	        }

	        return redirect()->route('negado'); //redirecionando a rota
	    }
	}
---------------------------------------------------------
#Login

criar a estrutura de login -> php artisan make:auth -> 
	->cria o HomeController / 
	->várias rotas referente ao login (arquivo web.php)
		Auth::routes(); //cria todas as rotas adicionais de login

	->cria as migrations users / table
é preciso rodar o comando -> php artisan make:migrate

protegendo no controlador (mostrar view somente para usuários logados) -> php artisan make:controller NomeControlador
	-> no controlador ->
	...
	public function __construct() {
		$this->middleware('auth');
	}
	
    public function index() {
    	echo "<h4>Lista de Produtos</h4>";
    	echo "<ul>";
    	echo "<li>Macarrão</li>";
    	echo "<li>Feijão</li>";
    	echo "<li>Carne Bovina</li>";
    	echo "<li>Arroz</li>";
    	echo "<li>Leite</li>";
    	echo "</ul>";
    }
    ...

protegendo na rota(mostrar view somente para usuários logados) -> 
			-> Route::get('/produtos', 'ProdutoControlador@index')->middleware('auth');

redirecionando a tela home/registro/reset/esqueceu a senha do laravel para outra view 
	-> arquivo app/Http/Controllers/Auth/LoginController.php ->
	-> arquivo app/Http/Controllers/Auth/ForgotPasswprdController.php ->
	-> arquivo app/Http/Controllers/Auth/RegisterController.php ->
	-> arquivo app/Http/Controllers/Auth/ResetController.php ->
	-> arquivo app/Http/Controllers/Auth/VerificationController.php ->
		-> protected $redirectTo = '/home'; //aqui você coloca a rota para qual será redirecionada após o login

verificando se o usuário está logado -> no controlador ->
	namespace App\Http\Controllers;

	use Illuminate\Http\Request;
	use Illuminate\Support\Facades\Auth;

	class DepartamentoControlador extends Controller
	{
	    public function index(){
	    	echo "<h4>Lista de Categorias</h4>";
	    	echo "<ul>";
	    	echo "<li>Alimentos</li>";
	    	echo "<li>Eletrônicos</li>";
	    	echo "<li>Móveis</li>";
	    	echo "<li>Informática</li>";
	    	echo "</ul>";

	    	// verifica se o usuário está logado
	    	if (Auth::check()) { 
	    		$user = Auth::user();
	    		echo "<h4>Você está logado!</h4>";
	    		echo "<p>" . $user->name . "</p>";
	    		echo "<p>" . $user->email . "</p>";
	    		echo "<p>" . $user->id . "</p>";
	    	}else {
	    		echo "<h4>Você não está logado!</h4>";
	    	}
	    }
	}

verificando se o usuário está logado -> na view ->

	@auth
		<h4>Você está logado!</h4>
		<p>{{ Auth::user()->name }} </p>
		<p>{{ Auth::user()->email }} </p>
		<p>{{ Auth::user()->id }} </p>
	@endauth

	@guest
		<h4>Você não está logado!</h4>
	@endguest
	
------------------------------------------------------------------------------------------
#Instalar Bootstrap via npm
cmd -> npm install (o arquivo package.json mostra as dependências que serão baixadas)
editar o arquivo o arquivo resources/js/app.js e comentar tudo referente a vue
cmd -> npm run dev (irá compilar os arquivos /js/app.js e /css/app.css na pasta public)
dentro da view basta incluir os arquivos css e js -> 
<html>
<head>
	<title>Página do Bootstrap</title>
	<link rel="stylesheet" type="text/css" href="{{asset('css/app.css')}}"> //usar asset
		ou
	<link rel="stylesheet" type="text/css" href="{{URL::to('css/app.css')}}"> //usar URL::to
	<meta name="csrf-token" content="{{ csrf_token() }}"> //evitar erro do formulário 
</head>
<body>
	<div class="alert alert-primary" role="alert">
	  Um simples alerta primary. Olha só!
	</div>
	<script type="text/javascript" src="{{asset('js/app.js')}}"></script> //usar asset
	ou
	<script type="text/javascript" src="{{URL::to('js/app.js')}}"></script> //usar URL::to
</body>
</html>
----------------------------------------------------------------------------------------------------
#Nomes das tabelas 
-> o nome da tabela deve ser o nome do modelo + s -> 
	-> model -> Cliente
	-> tabela -> clientes

-> informar o laraval sobre alteração de nomes das tabelas (fugindo do padrão) -> dentro de cada modelo ->
<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Alocacao extends Model {
	protected $table = 'desenvolvedores'; //incluir linha para fugir do padrão de nomenclarura de nome de tabelas
}
--------------------------------------
#Erros

SQLSTATE 42000: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes com PHP ->
	-> link -> 
		https://pt.stackoverflow.com/questions/245432/sqlstate-42000-syntax-error-or-access-violation-1071-specified-key-was-too-lon
		https://translate.googleusercontent.com/translate_c?depth=1&hl=pt-BR&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://laravel-news.com/laravel-5-4-key-too-long-error&xid=17259,15700022,15700186,15700191,15700253,15700255&usg=ALkJrhiyBESkKAZIPFitbpM7HqiZ1afykw
---------------------------------------------------------
Criando API e acessando via jQuery e Javascript

criando um modal com bootstrap + jQuery + Javascript
@extends('layout.app', ["current" => "produtos" ])

@section('body')
    <h4>Página de produtos</h4>
    <div class="card border">
    <div class="card-body">
        <h5 class="card-title">Cadastro de Categorias</h5>

        <table class="table table-ordered table-hover">
            <thead>
                <tr>
                    <th>Código</th>
                    <th>Nome da Categoria</th>
                    <th>Ações</th>
                </tr>
            </thead>
            <tbody>
                
            </tbody>
        </table>
    </div>
    <div class="card-footer">
	    //botão que chama o modal
        <button  class="btn btn-sm btn-primary" role="button" onclick="novoProduto()">Nova categoria</button> 
    </div>

    //criação do modal
    <div class="modal" tabindex="-1" role="dialog" id="dlgProdutos">
    	<div class="modal-dialog" role="document">
    		<div class="modal-content">
    			<form class="form-horizontal" id="formProduto">
    				<div class="modal-header">
    					<h4 class="modal-title">Novo Produto</h4>
    				</div>
    				<div class="modal-body">

    					<input type="hidden" id="id" class="form-control">
    					<div class="form-group">
    						<label class="control-label" for="nomeProduto">Nome do Produto</label>
    						<div class="input-group">
    							<input type="text" id="nomeProduto" class="form-control" placeholder="Nome do Produto">
    						</div>
    					</div>

    					<div class="form-group">
    						<label class="control-label" for="precoProduto">Preço do Produto</label>
    						<div class="input-group">
    							<input type="number" id="precoProduto" class="form-control" placeholder="Preço do Produto">
    						</div>
    					</div>

    					<div class="form-group">
    						<label class="control-label" for="quantidadeProduto">Quantidade do Produto</label>
    						<div class="input-group">
    							<input type="number" id="quantidadeProduto" class="form-control" placeholder="Quantidade do Produto">
    						</div>
    					</div>

    					<div class="form-group">
    						<label class="control-label" for="quantidadeProduto">Departamento do Produto</label>
    						<div class="input-group">
    							<select id="departamentoProduto" class="form-control"></select>
    						</div>
    					</div>
    				</div>

    				<div class="modal-footer">
    					<button type="submit" class="btn btn-primary">Salvar</button>
    					<button type="cancel" class="btn btn-secondary" data-dissmiss="modal">Cancelar</button>
    				</div>
    			</form>
    		</div>
    	</div>
    </div>
@endsection

@section('javascript') //seção de javascript
	<script type="text/javascript">
		function novoProduto() {
			$('#nomeProduto').val('') //limpando os campos do modal
			$('#precoProduto').val('') //limpando os campos do modal
			$('#quantidadeProduto').val('') //limpando os campos do modal
			$('#dlgProdutos').modal('show') //limpando os campos do modal
		}
	</script>
@endsection


Rotas api/
-> arquivo routes/api.php
-> cria a rota no arquivo api.php
-> para acessar no navegador -> 
	->	Route::get('/categorias', 'ControladorCategoria@indexJson'); 
	-> colocar /api/categorias

Retornar Json
-> public function indexJson()
    {
        $cats = Categoria::all();
        return json_encode($cats); //função que retorna como json

        //outra opção
        return $cats->toJson();
    }
-> O laravel automaticamente converte pra Json o retorno de variáveis. Não é obrigatório usar 'json_encode'

Carregando dados por meio de javascript
-> rotas ->
	Route::get('/categorias', 'ControladorCategoria@indexJson'); //para acessar no navegador basta colocar /api/categorias
	Route::resource('/produtos', 'ControladorProduto'); 

-> no controller -> 
	 public function indexView()
	    {
	        return view('produtos');
	    }

    public function index()
    {
        $prod = Produto::all();
        return $prod->toJson();
    }

-> na view ->
@section('javascript')
	<script type="text/javascript">

		// CSRF Setup TOKEN
		$.ajaxSetup({
			headers: {
				'X-CSRF-TOKEN': "{{ csrf_token() }}"
			}
		});	

		//função que antes de mostrar o modal limpa os seus campos
		function novoProduto() {
			$('#nomeProduto').val('') //limpa os campos
			$('#precoProduto').val('') //limpa os campos
			$('#quantidadeProduto').val('') //limpa os campos
			$('#dlgProdutos').modal('show') //mostra o modal
		}

		// função que carrega os dados no select do modal da página produtos
		function carregarCategorias(data) {
			$.getJSON('api/categorias', function(data){
				for(i=0; i<data.length; i++){
					opcao = '<option value="' +  data[i].id + '">' + data[i].nome + '</option>';
					$('#departamentoProduto').append(opcao);  
				}
			})
		}

		// função que cria a linha que será usada pela função carregarProdutos()
		function montaLinha(p){
			var linha = "<tr>" +  
				"<td>" + p.id + "</td>" +
				"<td>" + p.nome + "</td>" +
				"<td>" + p.estoque + "</td>" +
				"<td>" + p.preco + "</td>" +
				"<td>" + p.categoria_id + "</td>" +
				"<td>" + 
					'<button class="btn btn-sm btn-primary">Editar</button> ' + 
					'<button class="btn btn-sm btn-danger">Apagar</button>' +
				"</td>" +
			"</tr>"

			return linha
		}

		//função que carrega os dados na tabela da página produtos
		function carregarProdutos(){
			$.getJSON('/api/produtos', function(produtos){ //retorna um array
				for (i=0; i<produtos.length; i++) {
					linha = montaLinha(produtos[i])
					$('#tabelaProdutos>tbody').append(linha)
				}
			})
		}

		//ao carregar a página chama as duas funções abaixo
		$(function(){
			carregarCategorias() //carrega as categorias no select do modal
			carregarProdutos() //carrega os dados da tabela da página de produtos
		})
	</script>
@endsection